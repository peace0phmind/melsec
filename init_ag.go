// Code generated by https://github.com/expgo/ag DO NOT EDIT.
// Plugins:
//   - github.com/expgo/enum

package melsec

import (
	"errors"
	"fmt"
	"strings"
)

const (
	// CommTypeBinary is a CommType of type BINARY.
	CommTypeBinary CommType = "BINARY"
	// CommTypeAscii is a CommType of type ASCII.
	CommTypeAscii CommType = "ASCII"
)

const (
	// DeviceSm is a Device of type SM.
	DeviceSm Device = iota
	// DeviceSd is a Device of type SD.
	DeviceSd
	// DeviceX is a Device of type X.
	DeviceX
	// DeviceY is a Device of type Y.
	DeviceY
	// DeviceM is a Device of type M.
	DeviceM
	// DeviceL is a Device of type L.
	DeviceL
	// DeviceF is a Device of type F.
	DeviceF
	// DeviceV is a Device of type V.
	DeviceV
	// DeviceB is a Device of type B.
	DeviceB
	// DeviceD is a Device of type D.
	DeviceD
	// DeviceW is a Device of type W.
	DeviceW
	// DeviceTs is a Device of type TS.
	DeviceTs
	// DeviceTc is a Device of type TC.
	DeviceTc
	// DeviceTn is a Device of type TN.
	DeviceTn
	// DeviceSs is a Device of type SS.
	DeviceSs
	// DeviceSc is a Device of type SC.
	DeviceSc
	// DeviceSn is a Device of type SN.
	DeviceSn
	// DeviceCs is a Device of type CS.
	DeviceCs
	// DeviceCc is a Device of type CC.
	DeviceCc
	// DeviceCn is a Device of type CN.
	DeviceCn
	// DeviceSb is a Device of type SB.
	DeviceSb
	// DeviceSw is a Device of type SW.
	DeviceSw
	// DeviceDx is a Device of type DX.
	DeviceDx
	// DeviceDy is a Device of type DY.
	DeviceDy
	// DeviceR is a Device of type R.
	DeviceR
	// DeviceZr is a Device of type ZR.
	DeviceZr
)

const (
	// PlcTypeQ is a PlcType of type Q.
	PlcTypeQ PlcType = iota
	// PlcTypeL is a PlcType of type L.
	PlcTypeL
	// PlcTypeQnA is a PlcType of type QnA.
	PlcTypeQnA
	// PlcTypeIQl is a PlcType of type iQ-L.
	PlcTypeIQl
	// PlcTypeIQr is a PlcType of type iQ-R.
	PlcTypeIQr
)

var ErrInvalidCommType = errors.New("not a valid CommType")

var _CommTypeNameMap = map[string]CommType{
	"BINARY": CommTypeBinary,
	"binary": CommTypeBinary,
	"ASCII":  CommTypeAscii,
	"ascii":  CommTypeAscii,
}

// Name is the attribute of CommType.
func (x CommType) Name() string {
	if v, ok := _CommTypeNameMap[string(x)]; ok {
		return string(v)
	}
	return fmt.Sprintf("CommType(%s).Name", string(x))
}

// Val is the attribute of CommType.
func (x CommType) Val() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x CommType) IsValid() bool {
	_, ok := _CommTypeNameMap[string(x)]
	return ok
}

// String implements the Stringer interface.
func (x CommType) String() string {
	return x.Name()
}

// ParseCommType converts a string to a CommType.
func ParseCommType(value string) (CommType, error) {
	if x, ok := _CommTypeNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _CommTypeNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return "", fmt.Errorf("%s is %w", value, ErrInvalidCommType)
}

// MarshalText implements the text marshaller method.
func (x CommType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *CommType) UnmarshalText(text []byte) error {
	val, err := ParseCommType(string(text))
	if err != nil {
		return err
	}
	*x = val
	return nil
}

var ErrInvalidDevice = errors.New("not a valid Device")

var _DeviceName = "SMSDXYMLFVBDWTSTCTNSSSCSNCSCCCNSBSWDXDYRZR"

var _DeviceMapName = map[Device]string{
	DeviceSm: _DeviceName[0:2],
	DeviceSd: _DeviceName[2:4],
	DeviceX:  _DeviceName[4:5],
	DeviceY:  _DeviceName[5:6],
	DeviceM:  _DeviceName[6:7],
	DeviceL:  _DeviceName[7:8],
	DeviceF:  _DeviceName[8:9],
	DeviceV:  _DeviceName[9:10],
	DeviceB:  _DeviceName[10:11],
	DeviceD:  _DeviceName[11:12],
	DeviceW:  _DeviceName[12:13],
	DeviceTs: _DeviceName[13:15],
	DeviceTc: _DeviceName[15:17],
	DeviceTn: _DeviceName[17:19],
	DeviceSs: _DeviceName[19:21],
	DeviceSc: _DeviceName[21:23],
	DeviceSn: _DeviceName[23:25],
	DeviceCs: _DeviceName[25:27],
	DeviceCc: _DeviceName[27:29],
	DeviceCn: _DeviceName[29:31],
	DeviceSb: _DeviceName[31:33],
	DeviceSw: _DeviceName[33:35],
	DeviceDx: _DeviceName[35:37],
	DeviceDy: _DeviceName[37:39],
	DeviceR:  _DeviceName[39:40],
	DeviceZr: _DeviceName[40:42],
}

// Name is the attribute of Device.
func (x Device) Name() string {
	if v, ok := _DeviceMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("Device(%d).Name", x)
}

var _DeviceMapCode = map[Device]int{
	DeviceSm: 145,
	DeviceSd: 169,
	DeviceX:  156,
	DeviceY:  157,
	DeviceM:  144,
	DeviceL:  146,
	DeviceF:  147,
	DeviceV:  148,
	DeviceB:  160,
	DeviceD:  168,
	DeviceW:  180,
	DeviceTs: 193,
	DeviceTc: 192,
	DeviceTn: 194,
	DeviceSs: 199,
	DeviceSc: 198,
	DeviceSn: 200,
	DeviceCs: 196,
	DeviceCc: 195,
	DeviceCn: 197,
	DeviceSb: 161,
	DeviceSw: 181,
	DeviceDx: 162,
	DeviceDy: 163,
	DeviceR:  175,
	DeviceZr: 176,
}

// Code is the attribute of Device.
func (x Device) Code() int {
	if v, ok := _DeviceMapCode[x]; ok {
		return v
	}
	return 0
}

// Val is the attribute of Device.
func (x Device) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Device) IsValid() bool {
	_, ok := _DeviceMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x Device) String() string {
	return x.Name()
}

var _DeviceNameMap = map[string]Device{
	_DeviceName[0:2]:                    DeviceSm,
	strings.ToLower(_DeviceName[0:2]):   DeviceSm,
	_DeviceName[2:4]:                    DeviceSd,
	strings.ToLower(_DeviceName[2:4]):   DeviceSd,
	_DeviceName[4:5]:                    DeviceX,
	strings.ToLower(_DeviceName[4:5]):   DeviceX,
	_DeviceName[5:6]:                    DeviceY,
	strings.ToLower(_DeviceName[5:6]):   DeviceY,
	_DeviceName[6:7]:                    DeviceM,
	strings.ToLower(_DeviceName[6:7]):   DeviceM,
	_DeviceName[7:8]:                    DeviceL,
	strings.ToLower(_DeviceName[7:8]):   DeviceL,
	_DeviceName[8:9]:                    DeviceF,
	strings.ToLower(_DeviceName[8:9]):   DeviceF,
	_DeviceName[9:10]:                   DeviceV,
	strings.ToLower(_DeviceName[9:10]):  DeviceV,
	_DeviceName[10:11]:                  DeviceB,
	strings.ToLower(_DeviceName[10:11]): DeviceB,
	_DeviceName[11:12]:                  DeviceD,
	strings.ToLower(_DeviceName[11:12]): DeviceD,
	_DeviceName[12:13]:                  DeviceW,
	strings.ToLower(_DeviceName[12:13]): DeviceW,
	_DeviceName[13:15]:                  DeviceTs,
	strings.ToLower(_DeviceName[13:15]): DeviceTs,
	_DeviceName[15:17]:                  DeviceTc,
	strings.ToLower(_DeviceName[15:17]): DeviceTc,
	_DeviceName[17:19]:                  DeviceTn,
	strings.ToLower(_DeviceName[17:19]): DeviceTn,
	_DeviceName[19:21]:                  DeviceSs,
	strings.ToLower(_DeviceName[19:21]): DeviceSs,
	_DeviceName[21:23]:                  DeviceSc,
	strings.ToLower(_DeviceName[21:23]): DeviceSc,
	_DeviceName[23:25]:                  DeviceSn,
	strings.ToLower(_DeviceName[23:25]): DeviceSn,
	_DeviceName[25:27]:                  DeviceCs,
	strings.ToLower(_DeviceName[25:27]): DeviceCs,
	_DeviceName[27:29]:                  DeviceCc,
	strings.ToLower(_DeviceName[27:29]): DeviceCc,
	_DeviceName[29:31]:                  DeviceCn,
	strings.ToLower(_DeviceName[29:31]): DeviceCn,
	_DeviceName[31:33]:                  DeviceSb,
	strings.ToLower(_DeviceName[31:33]): DeviceSb,
	_DeviceName[33:35]:                  DeviceSw,
	strings.ToLower(_DeviceName[33:35]): DeviceSw,
	_DeviceName[35:37]:                  DeviceDx,
	strings.ToLower(_DeviceName[35:37]): DeviceDx,
	_DeviceName[37:39]:                  DeviceDy,
	strings.ToLower(_DeviceName[37:39]): DeviceDy,
	_DeviceName[39:40]:                  DeviceR,
	strings.ToLower(_DeviceName[39:40]): DeviceR,
	_DeviceName[40:42]:                  DeviceZr,
	strings.ToLower(_DeviceName[40:42]): DeviceZr,
}

// ParseDevice converts a string to a Device.
func ParseDevice(value string) (Device, error) {
	if x, ok := _DeviceNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _DeviceNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return Device(0), fmt.Errorf("%s is %w", value, ErrInvalidDevice)
}

// MarshalText implements the text marshaller method.
func (x Device) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Device) UnmarshalText(text []byte) error {
	val, err := ParseDevice(string(text))
	if err != nil {
		return err
	}
	*x = val
	return nil
}

var ErrInvalidPlcType = errors.New("not a valid PlcType")

var _PlcTypeName = "QLQnAiQ-LiQ-R"

var _PlcTypeMapName = map[PlcType]string{
	PlcTypeQ:   _PlcTypeName[0:1],
	PlcTypeL:   _PlcTypeName[1:2],
	PlcTypeQnA: _PlcTypeName[2:5],
	PlcTypeIQl: _PlcTypeName[5:9],
	PlcTypeIQr: _PlcTypeName[9:13],
}

// Name is the attribute of PlcType.
func (x PlcType) Name() string {
	if v, ok := _PlcTypeMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("PlcType(%d).Name", x)
}

var _PlcTypeMapNumFmt = map[PlcType]string{
	PlcTypeQ:   "%06d",
	PlcTypeL:   "%06d",
	PlcTypeQnA: "%06d",
	PlcTypeIQl: "%06d",
	PlcTypeIQr: "%08d",
}

// NumFmt is the attribute of PlcType.
func (x PlcType) NumFmt() string {
	if v, ok := _PlcTypeMapNumFmt[x]; ok {
		return v
	}
	return fmt.Sprintf("PlcType(%d).NumFmt", x)
}

// Val is the attribute of PlcType.
func (x PlcType) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x PlcType) IsValid() bool {
	_, ok := _PlcTypeMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x PlcType) String() string {
	return x.Name()
}

var _PlcTypeNameMap = map[string]PlcType{
	_PlcTypeName[0:1]:                   PlcTypeQ,
	strings.ToLower(_PlcTypeName[0:1]):  PlcTypeQ,
	_PlcTypeName[1:2]:                   PlcTypeL,
	strings.ToLower(_PlcTypeName[1:2]):  PlcTypeL,
	_PlcTypeName[2:5]:                   PlcTypeQnA,
	strings.ToLower(_PlcTypeName[2:5]):  PlcTypeQnA,
	_PlcTypeName[5:9]:                   PlcTypeIQl,
	strings.ToLower(_PlcTypeName[5:9]):  PlcTypeIQl,
	_PlcTypeName[9:13]:                  PlcTypeIQr,
	strings.ToLower(_PlcTypeName[9:13]): PlcTypeIQr,
}

// ParsePlcType converts a string to a PlcType.
func ParsePlcType(value string) (PlcType, error) {
	if x, ok := _PlcTypeNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _PlcTypeNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return PlcType(0), fmt.Errorf("%s is %w", value, ErrInvalidPlcType)
}

// MarshalText implements the text marshaller method.
func (x PlcType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *PlcType) UnmarshalText(text []byte) error {
	val, err := ParsePlcType(string(text))
	if err != nil {
		return err
	}
	*x = val
	return nil
}
